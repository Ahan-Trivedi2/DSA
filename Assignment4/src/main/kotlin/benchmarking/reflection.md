In this experiment, I tested five different sorting algorithms: Selection Sort, Insertion Sort, Merge Sort, Quick Sort, and Kotlin’s built-in sort to see how long each one took to organize lists of numbers of different sizes. For each test, I generated random lists of integers between 0 and 999, with list sizes of 10, 100, 1,000, 10,000, and 100,000 elements. Each algorithm was run once per list size, and I measured how long it took to sort the list using Kotlin’s built-in timing function. After the runs finished, I printed the results in a table to compare how the runtimes changed as the lists got larger.

From the results, I noticed that the simpler algorithms like Selection Sort and Insertion Sort took a lot longer when the list size became large. They were much slower than the others for 10,000 and 100,000 elements. On the other hand, Merge Sort, Quick Sort, and the built-in sort were much faster even for big lists. Quick Sort and the built-in sort had the best performance overall, especially for the largest data sets. This shows that algorithms with better time complexity, like O(n log n), handle larger inputs much more efficiently than the simpler O(n²) ones.